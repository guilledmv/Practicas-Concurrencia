//package Practica1;
import java.util.LinkedList;
import java.util.Queue;

import org.jcsp.lang.Alternative;

import org.jcsp.lang.Any2OneChannel;
import org.jcsp.lang.CSProcess;
import org.jcsp.lang.ProcessManager;

import org.jcsp.lang.Channel;
import org.jcsp.lang.Guard;
import org.jcsp.lang.One2OneChannel;

/**
 * Implementacion usando jcsp mediante peticiones aplazadas
 */

//Grupo: Guillermo De Miguel Villanueva (160262) , Marcos Arevalo Salas (160266)

public class EnclavamientoCSP implements CSProcess, Enclavamiento {

	// CANALES PARA RECIBIR EL ESTADO DEL RECURSO--> 1 CANAL POR METODO
	private final Any2OneChannel chAvisarPresencia;
	private final Any2OneChannel chLeerCambioBarrera;
	private final Any2OneChannel chLeerCambioFreno;
	private final Any2OneChannel chLeerCambioSemaforo;
	private final Any2OneChannel chAvisarPasoPorBaliza;

	public EnclavamientoCSP() {
		this.chAvisarPresencia = Channel.any2one();
		this.chLeerCambioBarrera = Channel.any2one();
		this.chLeerCambioFreno = Channel.any2one();
		this.chLeerCambioSemaforo = Channel.any2one();
		this.chAvisarPasoPorBaliza = Channel.any2one();
		new ProcessManager(this).start();
	}

	// CLASE AUXILIAR PARA LAS PETICIONES QUE VAMOS RECIBIENDO
	public static class PeticionAvisarPresencia {
		protected One2OneChannel channel;
		protected boolean value;

		public PeticionAvisarPresencia (One2OneChannel channel, boolean value) {
			this.channel = channel;
			this.value = value;
		}
	}
	// CLASE AUXILIAR PARA LAS PETICIONES QUE VAMOS RECIBIENDO
	public static class PeticionLeerCambioBarrera{
		protected One2OneChannel channel;
		protected boolean value;

		public PeticionLeerCambioBarrera(One2OneChannel channel, boolean value) {
			this.channel = channel;
			this.value = value;
		}
	}
	// CLASE AUXILIAR PARA LAS PETICIONES QUE VAMOS RECIBIENDO
	public static class PeticionLeerCambioFreno{
		protected One2OneChannel channel;
		protected boolean value;

		public PeticionLeerCambioFreno(One2OneChannel channel, boolean value) {
			this.channel = channel;
			this.value = value;
		}
	}
	// CLASE AUXILIAR PARA LAS PETICIONES QUE VAMOS RECIBIENDO
	public static class PeticionLeerCambioSemaforo{
		protected One2OneChannel channel;
		protected Control.Color color;
		protected int index;

		public PeticionLeerCambioSemaforo(One2OneChannel channel,
				Control.Color color,
				int index) {
			this.channel = channel;
			this.color = color;
			this.index = index;
		}
	}
	// CLASE AUXILIAR PARA LAS PETICIONES QUE VAMOS RECIBIENDO
	public static class PeticionAvisarPasoPorBaliza {
		protected One2OneChannel channel;
		protected int value;

		public PeticionAvisarPasoPorBaliza (One2OneChannel channel, int value) {
			this.channel = channel;
			this.value = value;
		}
	}

	// IMPLEMENTACION ENCLAVAMIENTO

	public void avisarPresencia(boolean presencia) {
		One2OneChannel ch = Channel.one2one();
		chAvisarPresencia.out().write(new PeticionAvisarPresencia(ch,presencia));
	}


	public boolean leerCambioBarrera(boolean abierta) {
		One2OneChannel ch = Channel.one2one();
		chLeerCambioBarrera.out().write(new PeticionLeerCambioBarrera(ch, abierta));
		return (Boolean) ch.in().read();
	}

	public boolean leerCambioFreno(boolean accionado) {
		One2OneChannel ch = Channel.one2one();
		chLeerCambioFreno.out().write(new PeticionLeerCambioFreno(ch, accionado));
		return (Boolean) ch.in().read();
	}

	public Control.Color leerCambioSemaforo(int i, Control.Color color) {
		if (i == 0 ) 
			throw new PreconditionFailedException("Semaforo 0 no existe");

		One2OneChannel ch = Channel.one2one();
		chLeerCambioSemaforo.out().write(new PeticionLeerCambioSemaforo(ch, color, i));
		return (Control.Color) ch.in().read();
	}

	public void avisarPasoPorBaliza(int i) {
		if (i == 0)
			throw new PreconditionFailedException("Baliza 0 no existe");

		One2OneChannel ch = Channel.one2one();
		chAvisarPasoPorBaliza.out().write(new PeticionAvisarPasoPorBaliza(ch,i));
	}

	// NOMBRES PARA LOS INDICES DE SERVICIOS
	static final int AVISAR_PRESENCIA = 0;
	static final int LEER_CAMBIO_BARRERA = 1;
	static final int LEER_CAMBIO_FRENO  = 2;
	static final int LEER_CAMBIO_SEMAFORO  = 3;
	static final int AVISAR_PASO_POR_BALIZA = 4;

	public void run() {
		// VARIABLES LOCALES PARA CONTROLAR EL ENCLAVAMIENTO

		boolean presencia; // DECLARAMOS EL ATRIBUTO PRESENCIA, PARA DETECTAR PRESENCIA EN EL CRUCE
		int [] trenes; 	// DECLARAMOS ARRAY DE TRENES PARA CONTROLAR EL PASO POR LAS BALIZAS
		Control.Color [] coloresBaliza; // DECLARAMOS UN ARRAY DE COLORES PARA LOS SEMAFOROS

		//DECLARAMOS ESTRUCTURAS AUXILIARES PARA ALMACENAR LAS PETICIONES APLAZADAS EN EL SERVIDOR

		Queue<PeticionLeerCambioBarrera> listaBarrera; // DECLARAMOS TRES COLAS PARA ALMACENAR LAS PETICIONES DE BARRERA, FRENO Y SEMAFORO
		Queue<PeticionLeerCambioFreno> listaFreno;
		Queue<PeticionLeerCambioSemaforo> listaSemaforo;


		// INICIALIZAMOS EL ESTADO DE NUESTROS RECURSOS
		presencia = false;
		trenes = new int [] {0,0,0,0};
		coloresBaliza = new Control.Color [] {Control.Color.VERDE,Control.Color.VERDE,Control.Color.VERDE,Control.Color.VERDE};

		// INICIALIZAMOS NUESTRAS COLAS DE PETICIONES
		listaBarrera = new LinkedList<PeticionLeerCambioBarrera>();
		listaFreno = new LinkedList<PeticionLeerCambioFreno>();
		listaSemaforo = new LinkedList<PeticionLeerCambioSemaforo>();

		// CONSTRUIMOS RECEPCION ALTERNATIVA
		Guard[] inputs = {
				chAvisarPresencia.in(),
				chLeerCambioBarrera.in(),
				chLeerCambioFreno.in(),
				chLeerCambioSemaforo.in(),
				chAvisarPasoPorBaliza.in()
		};

		Alternative services = new Alternative(inputs);

		// BUCLE DE SERVICIO
		while (true) {

			switch (services.fairSelect()) {

			case AVISAR_PRESENCIA: {
				// LEEMOS PETICION DEL CANAL
				PeticionAvisarPresencia petPresencia = (PeticionAvisarPresencia) chAvisarPresencia.in().read();
				// ACTUALIZAMOS ESTADO DEL RECURSO
				presencia = petPresencia.value;
				// INVOCA COLORES CORRECTOS
				coloresCorrectos(trenes,coloresBaliza,presencia);
				break;
			}
			case LEER_CAMBIO_BARRERA: {
				// LEEMOS PETICION
				PeticionLeerCambioBarrera petBar = (PeticionLeerCambioBarrera) chLeerCambioBarrera.in().read();
				// SI NO SE CUMPLE LA CPRE--> ENCOLAMOS
				if(petBar.value == (trenes[1] + trenes[2] == 0)) {
					listaBarrera.add(petBar);
					// SI SE CUMPLE, GUARDAMOS VALOR EN DICHO CANAL
				} else {
					petBar.channel.out().write((trenes[1] + trenes[2] == 0));
				}
				break;
			}
			case LEER_CAMBIO_FRENO: {
				// LEEMOS PETICION
				PeticionLeerCambioFreno petFren = (PeticionLeerCambioFreno) chLeerCambioFreno.in().read();
				// SI NO SE CUMPLE LA CPRE--> ENCOLAMOS
				if(petFren.value == (trenes[1] > 1 || trenes[2] > 1 || trenes[2] == 1 && presencia == true)) {
					listaFreno.add(petFren);
					// SI SE CUMPLE, GUARDAMOS VALOR EN DICHO CANAL
				} else {
					petFren.channel.out().write((trenes[1] > 1 || trenes[2] > 1 || trenes[2] == 1 && presencia == true));
				}
				break;
			}
			case LEER_CAMBIO_SEMAFORO: {
				// LEEMOS PETICION
				PeticionLeerCambioSemaforo petSem = (PeticionLeerCambioSemaforo) chLeerCambioSemaforo.in().read();
				// SI NO SE CUMPLE LA CPRE--> ENCOLAMOS
				if (petSem.color == coloresBaliza[petSem.index]) {
					listaSemaforo.add(petSem);
					// SI SE CUMPLE, GUARDAMOS VALOR EN DICHO CANAL
				} else {
					petSem.channel.out().write(coloresBaliza[petSem.index]);
				}
				break;
			}
			case AVISAR_PASO_POR_BALIZA: {
				// LEEMOS PETICION DEL CANAL
				PeticionAvisarPasoPorBaliza petBaliza =  (PeticionAvisarPasoPorBaliza) chAvisarPasoPorBaliza.in().read();
				// ACTUALIZO EL ESTADO DEL RECURSO
				trenes[petBaliza.value-1] = trenes[petBaliza.value-1] - 1;
				trenes[petBaliza.value] = trenes[petBaliza.value] + 1;

				// INVOCA COLORES CORRECTOS
				coloresCorrectos(trenes,coloresBaliza,presencia);
				break;
			}
			} // CIERRE swith

			//BLOQUEO Y DESBLOQUEO DE LAS PETICIONES
			// RECORRIDO DE LA COLA DE LAS PETICIONES DE BARRERA
			for( int i = 0 ; i < listaBarrera.size() ; i++) {
				PeticionLeerCambioBarrera petBar = listaBarrera.poll();				
				// SI SE CUMPLE LA CPRE DE BARRERA
				if( petBar.value != (trenes[1] + trenes[2] == 0)) {
					// POST
					petBar.channel.out().write((Boolean)(trenes[1] + trenes[2] == 0));

					// SI NO SE CUMPLE LA CPRE DE FRENO--> VUELVE A ENCOLAR EL ELEMENTO
				} else {

					listaBarrera.add(petBar);

				}
			} // CIERRE BUCLE COLA BARRERA
			// RECORRIDO DE LA COLA DE LAS PETICIONES DE FRENO
			for ( int j = 0 ; j < listaFreno.size() ; j++ ) { 
				PeticionLeerCambioFreno petFren = listaFreno.poll(); // OBTENEMOS PRIMER ELEMENTO DE LA COLA

				// SI SE CUMPLE LA CPRE DE FRENO Y EXISTEN PETICIONES EN COLA --> ESCRIBE EN CANAL
				if ( petFren.value != ((trenes[1] > 1) || (trenes[2] > 1) || (trenes[2] == 1) && (presencia == true))) {
					// POST
					petFren.channel.out().write((Boolean)((trenes[1] > 1) || (trenes[2] > 1) || (trenes[2] == 1) && presencia == true));

					// SI NO SE CUMPLE LA CPRE DE FRENO--> VUELVE A ENCOLAR EL ELEMENTO
				} else { 

					listaFreno.add(petFren);

				}
			} // CIERRE BUCLE COLA DE FRENO
			// RECORRIDO DE LA COLA DE LAS PETICIONES DE SEMAFORO
			for ( int z = 0 ; z < listaSemaforo.size() ; z++ ) {
				PeticionLeerCambioSemaforo petSem = listaSemaforo.poll(); // OBTENEMOS PRIMER ELEMENTO DE LA COLA

				// SI SE CUMPLE LA CPRE PARA SEMAFORO Y EXISTEN PETICIONES EN COLA --> ESCRIBE EN CANAL
				if(petSem.index == 1 && petSem.color != coloresBaliza[petSem.index] || petSem.index == 2 && petSem.color != coloresBaliza[petSem.index]
						|| petSem.index == 3 && petSem.color != coloresBaliza[petSem.index]) {
					petSem.channel.out().write((Control.Color) coloresBaliza[petSem.index]);
				}
				else { 

					listaSemaforo.add(petSem);

				}
			} // CIERRE BUCLE COLA SEMAFORO
		} // CIERRE BUCLE SERVIDOR
	} // CIERRE run()
	//METODO AUXILIAR DE ColoresCorrectos
	private static void coloresCorrectos(int [] arr, Control.Color colores[], boolean prueba ) {
		// IMPLEMENTACION COLORES CORRECTOS
		if( arr[1] > 0 ) {
			colores[1] = Control.Color.ROJO; 
		} if( arr[1] == 0 && ( arr[2] > 0 || prueba )) {
			colores[1] = Control.Color.AMARILLO; 	   
		} if( arr[1] == 0 && arr[2] == 0 && !prueba ) {
			colores[1] = Control.Color.VERDE; 
		} if( arr[2] > 0 || prueba ) {
			colores[2] = Control.Color.ROJO; 
		} if( arr[2] == 0 && !prueba ) {
			colores[2] = Control.Color.VERDE; 
		} 
		colores[3] = Control.Color.VERDE; 

	}
} // end CLASS
